#!/usr/bin/python3

# Module containing classes, variables, etc. for creating OVAL content
#
# Author: David Ries <ries@jovalcm.com>
# Author: Joy Latten <joy.latten@canonical.com>
# Copyright (C) 2015 Farnam Hall Ventures LLC
# Copyright (C) 2019 Canonical Ltd.
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 2 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.
#
# NOTES / TODOs
# This script creates OVAL ids based on the related CVE ID but does not
# currently increment the version number of generated elements when they
# change.

import datetime
import os
import random
import re
import shutil
import sys
import tempfile

from cvss_calculator import calculate_cvss as cvss_score
from xml.sax.saxutils import escape


def recursive_rm(dirPath):
    '''recursively remove directory'''
    names = os.listdir(dirPath)
    for name in names:
        path = os.path.join(dirPath, name)
        if not os.path.isdir(path):
            os.unlink(path)
        else:
            recursive_rm(path)
    os.rmdir(dirPath)

def _open(fn, mode, encoding='utf-8'):
    """ open file """
    fd = None
    if sys.version_info[0] < 3:
        fd = open(fn, mode=mode)
    else:
        fd = open(fn, mode=mode, encoding=encoding)
    return fd

class OvalGenerator:
    supported_oval_elements = ('definition', 'test', 'object', 'state',
                               'variable')
    generator_version = '1.1'
    oval_schema_version = '5.11.1'

    def __init__(self, release_codename, warn_method=False, outdir='./', prefix='', oval_format='dpkg'):
        """ constructor, set defaults for instances """

        self.release_codename = release_codename
        self.warn = warn_method or self.warn
        self.tmpdir = tempfile.mkdtemp(prefix='oval_lib-')
        self.output_dir = outdir
        self.oval_format = oval_format
        self.output_filepath = \
            '{0}com.ubuntu.{1}.cve.oval.xml'.format(prefix, self.release_codename)
        self.ns = 'oval:com.ubuntu.{0}'.format(self.release_codename)

    def __del__(self):
        """ deconstructor, clean up """
        if os.path.exists(self.tmpdir):
            recursive_rm(self.tmpdir)

    def generate_cve_definition(self, cve):
        """ generate an OVAL definition based on parsed CVE data """

        header = cve['header']
        # if the multiplier is not large enough, the tests IDs will
        # overlap on things with large numbers of binary packages.
        # if we ever have an issue that touches more than 1,000,000
        # binary packages, that will cause a problem.
        id_base = int(re.sub('[^0-9]', '', header['Candidate'])) * 1000000
        if not self.unique_id_base(id_base, header['Source-note']):
            self.warn('Calculated id_base "{0}" based on candidate value "{1}" is not unique. Skipping CVE.'.format(id_base, header['Candidate']))

        # make test(s) for each package
        test_refs = []
        packages = cve['packages']
        for package in sorted(packages.keys()):
            releases = packages[package]['Releases']
            for release in sorted(releases.keys()):
                if release == self.release_codename:
                    release_status = releases[release]
                    if 'bin-pkgs' in release_status and release_status['bin-pkgs']:
                        test_ref = self.get_oval_test_for_package({
                            'name': package,
                            'binaries': release_status['bin-pkgs'],
                            'status': release_status['status'],
                            'note': release_status['note'],
                            'fix-version': release_status['fix-version'] if 'fix-version' in release_status else '',
                            'id_base': id_base + len(test_refs),
                            'source-note': header['Source-note']
                        })
                        if test_ref:
                            test_refs.append(test_ref)

        # if no packages for this release, then we're done
        if not len(test_refs):
            return False

        # convert CVE data to OVAL definition metadata
        mapping = {
            'ns': escape(self.ns),
            'id_base': id_base,
            'codename': escape(self.release_codename),
            'release_version': escape(self.release_version),
            'applicability_def_id': escape(
                self.release_applicability_definition_id),
            'cve_title': escape(header['Candidate']),
            'description': escape('{0} {1}'.format(header['Description'],
                                  header['Ubuntu-Description']).strip()),
            'priority': escape(header['Priority']),
            'criteria': '',
            'references': '',
            'notes': ''
        }

        # convert test_refs to criteria
        if len(test_refs) == 1:
            negation_attribute = 'negate = "true" ' \
                if 'negate' in test_refs[0] and test_refs[0]['negate'] else ''
            mapping['criteria'] = \
                '<criterion test_ref="{0}" comment="{1}" {2}/>'.format(
                    test_refs[0]['id'], escape(test_refs[0]['comment']), negation_attribute)
        else:
            criteria = []
            criteria.append('<criteria operator="OR">')
            for test_ref in test_refs:
                negation_attribute = 'negate = "true" ' \
                    if 'negate' in test_ref and test_ref['negate'] else ''
                criteria.append(
                    '    ' +
                    '<criterion test_ref="{0}" comment="{1}" {2}/>'.format(
                        test_ref['id'],
                        escape(test_ref['comment']), negation_attribute))
            criteria.append('</criteria>')
            mapping['criteria'] = '\n                    '.join(criteria)

        # convert notes
        if header['Notes']:
            mapping['notes'] = '\n                <oval:notes>' + \
                               '\n                    <oval:note>{0}</oval:note>'.format(escape(header['Notes'])) + \
                               '\n                </oval:notes>'

        # convert additional data <advisory> metadata elements
        advisory = []
        advisory.append('<severity>{0}</severity>'.format(
            escape(header['Priority'].title())))
        advisory.append(
            '<rights>Copyright (C) {0}Canonical Ltd.</rights>'.format(escape(
                header['PublicDate'].split('-', 1)[0] + ' '
                if header['PublicDate'] else '')))
        if header['PublicDate']:
            advisory.append('<public_date>{0}</public_date>'.format(
                escape(header['PublicDate'])))
        if header['PublicDateAtUSN']:
            advisory.append(
                '<public_date_at_usn>{0}</public_date_at_usn>'.format(escape(
                    header['PublicDateAtUSN'])))
        if header['Assigned-to']:
            advisory.append('<assigned_to>{0}</assigned_to>'.format(escape(
                header['Assigned-to'])))
        if header['Discovered-by']:
            advisory.append('<discovered_by>{0}</discovered_by>'.format(escape(
                header['Discovered-by'])))
        if header['CRD']:
            advisory.append('<crd>{0}</crd>'.format(escape(header['CRD'])))
        for bug in header['Bugs']:
            advisory.append('<bug>{0}</bug>'.format(escape(bug)))
        for ref in header['References']:
            if ref.startswith('https://cve.mitre'):
                cve_title = ref.split('=')[-1].strip()
                if not cve_title:
                    continue
                mapping['cve_title'] = escape(cve_title)
                mapping['references'] = '\n                    <reference source="CVE" ref_id="{0}" ref_url="{1}" />'.format(mapping['cve_title'], escape(ref))
            else:
                advisory.append('<ref>{0}</ref>'.format(escape(ref)))
        mapping['advisory_elements'] = '\n                        '.join(advisory)

        if self.oval_format == 'dpkg':
            mapping['os_release_check'] = """<extend_definition definition_ref="{applicability_def_id}" comment="Ubuntu {release_version} ({codename}) is installed." applicability_check="true" />""".format(**mapping)
        else:
            mapping['os_release_check'] = ''

        self.queue_element('definition', """
            <definition class="vulnerability" id="{ns}:def:{id_base}0" version="1">
                <metadata>
                    <title>{cve_title} on Ubuntu {release_version} ({codename}) - {priority}.</title>
                    <description>{description}</description>
                    <affected family="unix">
                        <platform>Ubuntu {release_version}</platform>
                    </affected>{references}
                    <advisory>
                        {advisory_elements}
                    </advisory>
                </metadata>{notes}
                <criteria>
                    {os_release_check}
                    {criteria}
                </criteria>
            </definition>\n""".format(**mapping))

    def get_oval_test_for_package(self, package):
        """ create OVAL test and dependent objects for this package status
                @package = {
                    'name'          : '<package name>',
                    'binaries'      : [ '<binary_pkg_name', '<binary_pkg_name', ... ],
                    'status'        : '<not-applicable | unknown | vulnerable | fixed>',
                    'note'          : '<a description of the status>',
                    'fix-version'   : '<the version in which the issue was fixed, if applicable>',
                    'id_base'       : a base for the integer section of the OVAL id,
                    'source-note'   : a note about the datasource for debugging
                }
        """

        if package['status'] == 'fixed' and not package['fix-version']:
            self.warn('"{0}" package in {1} is marked fixed, but missing a fix-version. Changing status to vulnerable.'.format(package['name'], package['source-note']))
            package['status'] = 'vulnerable'

        if package['status'] == 'not-applicable':
            # if the package status is not-applicable, skip it!
            return False
        elif package['status'] == 'not-vulnerable':
            # if the packaget status is not-vulnerable, skip it!
            return False
            """
            object_id = self.get_package_object_id(package['name'], package['id_base'], 1)

            test_title = "Returns true whether or not the '{0}' package exists.".format(package['name'])
            test_id = self.get_package_test_id(package['name'], package['id_base'], test_title, object_id, None, 1, 'any_exist')

            package['note'] = package['name'] + package['note']
            return {'id': test_id, 'comment': package['note'], 'negate': True}
            """
        elif package['status'] == 'vulnerable':
            object_id = self.get_package_object_id(package['name'], package['binaries'], package['id_base'])

            test_title = "Does the '{0}' package exist?".format(package['name'])
            test_id = self.get_package_test_id(package['name'], package['id_base'], test_title, object_id)

            package['note'] = package['name'] + package['note']
            return {'id': test_id, 'comment': package['note']}
        elif package['status'] == 'fixed':
            object_id = self.get_package_object_id(package['name'], package['binaries'], package['id_base'])

            state_id = self.get_package_version_state_id(package['id_base'], package['fix-version'])

            test_title = "Does the '{0}' package exist and is the version less than '{1}'?".format(package['name'], package['fix-version'])
            test_id = self.get_package_test_id(package['name'], package['id_base'], test_title, object_id, state_id)

            package['note'] = package['name'] + package['note']
            return {'id': test_id, 'comment': package['note']}
        else:
            if package['status'] != 'unknown':
                self.warn('"{0}" is not a supported package status. Outputting for "unknown" status.'.format(package['status']))

            if not hasattr(self, 'id_unknown_test'):
                self.id_unknown_test = '{0}:tst:10'.format(self.ns)
                self.queue_element('test', """
                    <ind-def:unknown_test id="{0}" check="all" comment="The result of this test is always UNKNOWN." version="1" />\n""".format(self.id_unknown_test))

            package['note'] = package['name'] + package['note']
            return {'id': self.id_unknown_test, 'comment': package['note']}

    def add_release_applicability_definition(self, version,
                                             kernel_version_pattern, id):
        """ add platform/release applicability OVAL definition for codename """

        mapping = {
            'ns': self.ns,
            'id_base': id,
            'codename': self.release_codename,
            'release_version': version,
            'kernel_version_pattern': kernel_version_pattern
        }
        self.release_version = version
        self.release_applicability_definition_id = \
            '{ns}:def:{id_base}0'.format(**mapping)

        if self.oval_format == 'dpkg':
            self.queue_element('definition', """
                <definition class="inventory" id="{ns}:def:{id_base}0" version="1">
                    <metadata>
                        <title>Check that Ubuntu {release_version} ({codename}) is installed.</title>
                        <description></description>
                    </metadata>
                    <criteria>
                        <criterion test_ref="{ns}:tst:{id_base}0" comment="The host is part of the unix family." />
                        <criterion test_ref="{ns}:tst:{id_base}1" comment="The host is running Ubuntu {codename}." />
                    </criteria>
                </definition>\n""".format(**mapping))
    
            self.queue_element('test', """
                <ind-def:family_test id="{ns}:tst:{id_base}0" check="at least one" check_existence="at_least_one_exists" version="1" comment="Is the host part of the unix family?">
                    <ind-def:object object_ref="{ns}:obj:{id_base}0"/>
                    <ind-def:state state_ref="{ns}:ste:{id_base}0"/>
                </ind-def:family_test>
    
                <ind-def:textfilecontent54_test id="{ns}:tst:{id_base}1" check="at least one" check_existence="at_least_one_exists" version="1" comment="Is the host running Ubuntu {codename}?">
                    <ind-def:object object_ref="{ns}:obj:{id_base}1"/>
                    <ind-def:state state_ref="{ns}:ste:{id_base}1"/>
                </ind-def:textfilecontent54_test>\n""".format(**mapping))
    
            # /etc/lsb-release has to be a single path, due to some
            # environments (namely snaps) not being allowed to list the
            # content of /etc/
            self.queue_element('object', """
                <ind-def:family_object id="{ns}:obj:{id_base}0" version="1" comment="The singleton family object."/>
    
                <ind-def:textfilecontent54_object id="{ns}:obj:{id_base}1" version="1" comment="The singleton release codename object.">
                    <ind-def:filepath>/etc/lsb-release</ind-def:filepath>
                    <ind-def:pattern operation="pattern match">^[\\s\\S]*DISTRIB_CODENAME=([a-z]+)$</ind-def:pattern>
                    <ind-def:instance datatype="int">1</ind-def:instance>
                </ind-def:textfilecontent54_object>\n""".format(**mapping))
    
            self.queue_element('state', """
                <ind-def:family_state id="{ns}:ste:{id_base}0" version="1" comment="The singleton family object.">
                    <ind-def:family>unix</ind-def:family>
                </ind-def:family_state>
    
                <ind-def:textfilecontent54_state id="{ns}:ste:{id_base}1" version="1" comment="Ubuntu {release_version}">
                    <ind-def:subexpression>{codename}</ind-def:subexpression>
                </ind-def:textfilecontent54_state>\n""".format(**mapping))

    def get_package_object_id(self, name, bin_pkgs, id_base, version=1):
        """ create unique object for each package and return its OVAL id """
        if not hasattr(self, 'package_objects'):
            self.package_objects = {}

        key = tuple(sorted(bin_pkgs))

        if key not in self.package_objects:
            object_id = '{0}:obj:{1}0'.format(self.ns, id_base)

            if len(bin_pkgs) > 1:
                # create variable for binary package names
                variable_id = '{0}:var:{1}0'.format(self.ns, id_base)
                if self.oval_format == 'dpkg':
                    variable_values = '</value>\n                        <value>'.join(bin_pkgs)
                    self.queue_element('variable', """
                        <constant_variable id="{0}" version="{1}" datatype="string" comment="'{2}' package binaries">
                            <value>{3}</value>
                        </constant_variable>\n""".format(variable_id, version, name, variable_values))

                    # create an object that references the variable
                    self.queue_element('object', """
                        <linux-def:dpkginfo_object id="{0}" version="{1}" comment="The '{2}' package binaries.">
                            <linux-def:name var_ref="{3}" var_check="at least one" />
                        </linux-def:dpkginfo_object>\n""".format(object_id, version, name, variable_id))

                else:
                    variable_values = '\s+(.*)</value>\n                        <value>^'.join(bin_pkgs)
                    self.queue_element('variable', """
                        <constant_variable id="{0}" version="{1}" datatype="string" comment="'{2}' package binaries">
                            <value>^{3}\s+(.*)</value>
                        </constant_variable>\n""".format(variable_id, version, name, variable_values))

                    # create an object that references the variable
                    self.queue_element('object', """
                        <ind-def:textfilecontent54_object id="{0}" version="{1}" comment="The '{2}' package binaries.">
                            <ind-def:path>.</ind-def:path>
                            <ind-def:filename>manifest</ind-def:filename>
                            <ind-def:pattern operation="pattern match" datatype="string" var_ref="{3}" var_check="at least one" />
                            <ind-def:instance operation="greater than or equal" datatype="int">1</ind-def:instance>
                        </ind-def:textfilecontent54_object>\n""".format(object_id, version, name, variable_id))

            else:
                if self.oval_format == 'dpkg':
                    # 1 binary package, so just use name in object (no variable)
                    self.queue_element('object', """
                        <linux-def:dpkginfo_object id="{0}" version="{1}" comment="The '{2}' package binary.">
                            <linux-def:name>{3}</linux-def:name>
                        </linux-def:dpkginfo_object>\n""".format(object_id, version, name, bin_pkgs[0]))
                else:
                    variable_id = '{0}:var:{1}0'.format(self.ns, id_base)
                    variable_values = '\s+(.*)</value>\n                        <value>^'.join(bin_pkgs)
                    self.queue_element('variable', """
                        <constant_variable id="{0}" version="{1}" datatype="string" comment="'{2}' package binaries">
                            <value>^{3}\s+(.*)</value>
                        </constant_variable>\n""".format(variable_id, version, name, variable_values))
                    self.queue_element('object', """
                        <ind-def:textfilecontent54_object id="{0}" version="{1}" comment="The '{2}' package binary.">
                            <ind-def:path>.</ind-def:path>
                            <ind-def:filename>manifest</ind-def:filename>
                            <ind-def:pattern operation="pattern match" datatype="string" var_ref="{3}" var_check="at least one" />
                            <ind-def:instance operation="greater than or equal" datatype="int">1</ind-def:instance>
                        </ind-def:textfilecontent54_object>\n""".format(object_id, version, name, variable_id))

            self.package_objects[key] = object_id

        return self.package_objects[key]

    def get_package_version_state_id(self, id_base, fix_version, version=1):
        """ create unique states for each version and return its OVAL id """
        if not hasattr(self, 'package_version_states'):
            self.package_version_states = {}

        key = fix_version
        if key not in self.package_version_states:
            state_id = '{0}:ste:{1}0'.format(self.ns, id_base)
            if self.oval_format == 'dpkg':
                self.queue_element('state', """
                    <linux-def:dpkginfo_state id="{0}" version="{1}" comment="The package version is less than '{2}'.">
                        <linux-def:evr datatype="debian_evr_string" operation="less than">{2}</linux-def:evr>
                    </linux-def:dpkginfo_state>\n""".format(state_id, version, fix_version))
            else:
                self.queue_element('state', """
                    <ind-def:textfilecontent54_state id="{0}" version="{1}" comment="The package version is less than '{2}'.">
                        <ind-def:subexpression datatype="debian_evr_string" operation="less than">{2}</ind-def:subexpression>
                    </ind-def:textfilecontent54_state>\n""".format(state_id, version, fix_version))
            self.package_version_states[key] = state_id

        return self.package_version_states[key]

    def get_package_test_id(self, name, id_base, test_title, object_id, state_id=None, version=1, check_existence='at_least_one_exists'):
        """ create unique test for each parameter set and return its OVAL id """
        if not hasattr(self, 'package_tests'):
            self.package_tests = {}

        key = (name, test_title, object_id, state_id)
        if key not in self.package_tests:
            test_id = '{0}:tst:{1}0'.format(self.ns, id_base)
            if self.oval_format == 'dpkg':
                state_ref = '\n                    <linux-def:state state_ref="{0}" />'.format(state_id) if state_id else ''
                self.queue_element('test', """
                    <linux-def:dpkginfo_test id="{0}" version="{1}" check_existence="{5}" check="at least one" comment="{2}">
                        <linux-def:object object_ref="{3}"/>{4}
                    </linux-def:dpkginfo_test>\n""".format(test_id, version, test_title, object_id, state_ref, check_existence))
            else:
                state_ref = '\n                    <ind-def:state state_ref="{0}" />'.format(state_id) if state_id else ''
                self.queue_element('test', """
                    <ind-def:textfilecontent54_test id="{0}" version="{1}" check_existence="{5}" check="at least one" comment="{2}">
                        <ind-def:object object_ref="{3}"/>{4}
                    </ind-def:textfilecontent54_test>\n""".format(test_id, version, test_title, object_id, state_ref, check_existence))
            self.package_tests[key] = test_id

        return self.package_tests[key]

    def queue_element(self, element, xml):
        """ add an OVAL element to an output queue file """
        if element not in OvalGenerator.supported_oval_elements:
            self.warn('"{0}" is not a supported OVAL element.'.format(element))
            return

        if not hasattr(self, 'tmp'):
            self.tmp = {}
            self.tmp_n = random.randrange(1000000, 9999999)

        if element not in self.tmp:
            self.tmp[element] = self._open(os.path.join(self.tmpdir,
                                           './queue.{0}.{1}.xml'.format(
                                               self.tmp_n, element)), 'wt')

        # trim and fix indenting (assumes fragment is nicely indented internally)
        xml = xml.strip('\n')
        base_indent = re.match(r'\s*', xml).group(0)
        xml = re.sub('^{0}'.format(base_indent), '        ', xml, 0,
                     re.MULTILINE)

        self.tmp[element].write(xml + '\n')

    def write_to_file(self):
        """ dequeue all elements into one OVAL definitions file and clean up """
        # close queue files for writing and then open for reading
        for key in self.tmp:
            self.tmp[key].close()
            self.tmp[key] = self._open(self.tmp[key].name, 'rt')

        tmp = os.path.join(self.tmpdir, self.output_filepath)
        with self._open(tmp, 'wt') as f:
            # add header
            oval_timestamp = datetime.datetime.utcnow().strftime(
                '%Y-%m-%dT%H:%M:%S')
            f.write("""<oval_definitions
    xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5"
    xmlns:ind-def="http://oval.mitre.org/XMLSchema/oval-definitions-5#independent"
    xmlns:oval="http://oval.mitre.org/XMLSchema/oval-common-5"
    xmlns:unix-def="http://oval.mitre.org/XMLSchema/oval-definitions-5#unix"
    xmlns:linux-def="http://oval.mitre.org/XMLSchema/oval-definitions-5#linux"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://oval.mitre.org/XMLSchema/oval-common-5 oval-common-schema.xsd   http://oval.mitre.org/XMLSchema/oval-definitions-5 oval-definitions-schema.xsd   http://oval.mitre.org/XMLSchema/oval-definitions-5#independent independent-definitions-schema.xsd   http://oval.mitre.org/XMLSchema/oval-definitions-5#unix unix-definitions-schema.xsd   http://oval.mitre.org/XMLSchema/oval-definitions-5#macos linux-definitions-schema.xsd">

    <generator>
        <oval:product_name>Canonical CVE OVAL Generator</oval:product_name>
        <oval:product_version>{0}</oval:product_version>
        <oval:schema_version>{1}</oval:schema_version>
        <oval:timestamp>{2}</oval:timestamp>
    </generator>\n""".format(OvalGenerator.generator_version, OvalGenerator.oval_schema_version, oval_timestamp))

            # add queued file content
            for element in OvalGenerator.supported_oval_elements:
                if element in self.tmp:
                    f.write("\n    <{0}s>\n".format(element))
                    f.write(self.tmp[element].read().rstrip())
                    f.write("\n    </{0}s>".format(element))

            # add footer
            f.write("\n</oval_definitions>")

        # close and delete queue files
        for key in self.tmp:
            self.tmp[key].close()
            os.remove(self.tmp[key].name)

        # close self.output_filepath and move into place
        f.close()
        shutil.move(tmp, os.path.join(self.output_dir, self.output_filepath))

    def unique_id_base(self, id_base, note):
        """ queue a warning message """
        if not hasattr(self, 'id_bases'):
            self.id_bases = {}
        is_unique = id_base not in self.id_bases.keys()
        if not is_unique:
            self.warn('ID Base collision {0} in {1} and {2}.'.format(
                id_base, note, self.id_bases[id_base]))
        self.id_bases[id_base] = note
        return is_unique

    def warn(self, message):
        """ print a warning message """
        print('WARNING: {0}'.format(message))


class OvalGeneratorUSN():
    supported_oval_elements = ('definition', 'test', 'object', 'state',
                               'variable')
    cve_base_url = 'https://people.canonical.com/~ubuntu-security/cve/{}/{}.html'
    mitre_base_url = 'https://cve.mitre.org/cgi-bin/cvename.cgi?name={}'
    usn_base_url = 'https://ubuntu.com/security/notices/USN-{}'
    lookup_cve_path = ['./active', './retired']
    generator_version = '1'
    oval_schema_version = '5.11.1'
    priorities = {'negligible': 0, 'low': 1, 'medium': 2, 'high': 3, 'critical': 4}

    def __init__(self, incremental, release, release_codename, outdir='./'):
        # TODO: create a key: value schema (e.g: USN-44560-1:
        # {definition: <def>, test: <test>, object: <obj> ...
        # for the 'current' oval
        # database created and so, add just new USNs to it through the
        # incremental option.
        self.incremental = incremental
        self.release = release
        self.release_codename = release_codename
        self.current_oval = None
        self.tmpdir = tempfile.mkdtemp(prefix='oval_lib-')
        self.output_dir = outdir
        self.output_filepath = \
            'com.ubuntu.{0}.usn.oval.xml'.format(self.release_codename)
        self.ns = 'oval:com.ubuntu.{0}'.format(self.release_codename)
        self.oval_structure = None
        self.load_oval_file_structures()
        self.create_release_oval_info()

        # TODO: create a way to append a new usn info into oval usn database
        if incremental:
            self.current_oval = self.load_current_oval(release)

    def load_oval_file_structures(self):
        _file = '{}.oval.usn'.format(self.release_codename)
        mode = 'w'

        self.oval_structure = {
            key: _open(os.path.join(self.tmpdir, '{}.{}.xml'.format(_file, key)),
                                   mode=mode, encoding='utf-8')  for key in
                    ['definition', 'test', 'object', 'state', 'variable']
        }

    def create_release_oval_info(self):
        oval_release_structure = {
            'r_def': self.create_release_definition(),
            'r_test': self.create_release_test(),
            'r_obj': self.create_release_object(),
            'r_ste': self.create_release_state()
        }

        self.oval_structure['definition'].write(oval_release_structure['r_def'])
        self.oval_structure['test'].write(oval_release_structure['r_test'])
        self.oval_structure['object'].write(oval_release_structure['r_obj'])
        self.oval_structure['state'].write(oval_release_structure['r_ste'])

    def create_release_definition(self):
        mapping = {
            'id': self.release['id'] * 10,
            'ns': self.ns,
            'title': "Check that Ubuntu {} ({})".format(self.release['desc'], self.release_codename),
            'comment': "Ubuntu {} ({})".format(self.release['desc'], self.release_codename)
        }

        definition =\
        """
        <definition class="inventory" id="{ns}:def:{id}" version="1">
           <metadata>
              <title>{title} is installed.</title>
              <description></description>
           </metadata>
           <criteria>
              <criterion test_ref="{ns}:tst:{id}" comment="{comment} is installed." />
           </criteria>
        </definition>""".format(**mapping)

        return definition

    def create_release_test(self):
        mapping = {
            'id': self.release['id'] * 10,
            'ns': self.ns,
            'comment': "Ubuntu {} ({})".format(self.release['desc'], self.release_codename)
        }

        test =\
        """
        <ind:textfilecontent54_test check="at least one" check_existence="at_least_one_exists" id="{ns}:tst:{id}" version="1" comment="{comment} is installed.">
           <ind:object object_ref="{ns}:obj:{id}" />
           <ind:state state_ref="{ns}:ste:{id}" />
        </ind:textfilecontent54_test>""".format(**mapping)

        return test

    def create_release_object(self):
        mapping = {
            'id': self.release['id'] * 10,
            'ns': self.ns,
        }

        _object =\
        """
        <ind:textfilecontent54_object id="{ns}:obj:{id}" version="1">
           <ind:filepath datatype="string">/etc/lsb-release</ind:filepath>
             <ind:pattern operation="pattern match">^[\s\S]*DISTRIB_CODENAME=([a-z]+)$</ind:pattern>
           <ind:instance datatype="int">1</ind:instance>
        </ind:textfilecontent54_object>""".format(**mapping)

        return _object

    def create_release_state(self):
        mapping = {
            'id': self.release['id'] * 10,
            'ns': self.ns,
            'comment': "Ubuntu {}".format(self.release['desc']),
            'release_name': self.release_codename,
        }

        state =\
        """
        <ind:textfilecontent54_state id="{ns}:ste:{id}" version="1" comment="{comment}">
           <ind:subexpression datatype="string" operation="equals">{release_name}</ind:subexpression>
        </ind:textfilecontent54_state>""".format(**mapping)

        return state

    def create_bug_references(self, urls):
        bug_urls = []
        alien_urls = []
        bugs = ""

        for url in urls:
            is_bug = re.match("https://(bugs\.)?launchpad.net/bugs/\d+", url)

            if is_bug:
                bug_urls.append(url)
            else:
                alien_urls.append(url)

        for bug in bug_urls:
            bug_id = re.findall('\d+', bug)[0]
            bugs += \
                """
                <launchpad href="{}" id="{}">Some text about the bug</launchpad>
                """.format(bug, bug_id)

        for alien in alien_urls:
            bugs += \
                """<information href="{}">Reference information {}</information>
                """.format(alien, alien)

        return bugs.strip()

    def create_cves_references(self, cves):
        references = ""
        for cve in cves:
            references += \
                    """  <reference source="CVE" ref_url="{}" ref_id="{}"/>
            """.format(cve['CVE_URL'], cve['Candidate'])

        return references.strip()

    def get_usn_severity(self, cves):
        if not cves:
            return "None"

        max_severity = max(cves)
        usn_severity = [key for key in self.priorities.items()
                            if key[1] == max_severity][0][0]
        return usn_severity.capitalize()

    def create_usn_definition(self, usn_object, usn_number, id_base):
        urls, cves_info = self.format_cves_info(usn_object['cves'])
        cve_references = self.create_cves_references(cves_info)
        bug_references = self.create_bug_references(urls)

        usn_severity = self.get_usn_severity([self.priorities[cve['Priority']]
                                                        for cve in cves_info])

        # Bugged USN sometimes has isummary others don't
        if 'isummary' in usn_object:
            summary_info = usn_object['isummary']
        else:
            summary_info = usn_object['summary']

        mapping = {
            'id': id_base,
            'usn_id': usn_object['id'],
            'ns': self.ns,
            'title': "{} -- {}".format(usn_object['id'], usn_object['title']),
            'plataform': "Ubuntu {}".format(self.release['desc']),
            'usn_url': self.usn_base_url.format(usn_object['id']),
            'description': ' '.join(summary_info.strip().split('\n')),
            'cves_references': cve_references,
            'bug_references': bug_references,
            'severity': usn_severity,
            'usn_timestamp': datetime.datetime.fromtimestamp(usn_object['timestamp']).strftime('%Y-%m-%d'),
        }

        definition = \
        """
        <definition id="{ns}:def:{id}" version="1" class="patch">
           <metadata>
              <title>{title}</title>
              <affected family="unix">
                 <platform>{plataform}</platform>
              </affected>
              <reference source="USN" ref_url="{usn_url}" ref_id="{usn_id}"/>
              {cves_references}
              {bug_references}
              <description>{description}</description>
              <advisory from="security@ubuntu.com">
                 <severity>{severity}</severity>
                 <issued date="{usn_timestamp}"/>
              </advisory>
           </metadata>
           <criteria>
              <criterion test_ref="{ns}:tst:{id}" comment="?" />
           </criteria>
        </definition>""".format(**mapping)

        return definition

    def create_usn_test(self, id_base):
        mapping = {
            'id': id_base,
            'ns': self.ns,
        }

        test = \
        """
        <linux:dpkginfo_test id="{ns}:tst:{id}" version="1" check_existence="at_least_one_exists" check="at least one" comment="?">
          <linux:object object_ref="{ns}:obj:{id}"/>
          <linux:state state_ref="{ns}:ste:{id}"/>
        </linux:dpkginfo_test>""".format(**mapping)

        return test

    def create_usn_object(self, id_base):
        mapping = {
            'id': id_base,
            'ns': self.ns,
        }

        _object = \
        """
        <linux:dpkginfo_object id="{ns}:obj:{id}" version="1">
          <linux:name var_ref="{ns}:var:{id}" var_check="at least one" />
        </linux:dpkginfo_object>""".format(**mapping)

        return _object

    def create_usn_state(self, binarie_version, id_base):
        mapping = {
            'id': id_base,
            'ns': self.ns,
            'bversion': binarie_version,
        }

        state = \
        """
        <linux:dpkginfo_state id="{ns}:ste:{id}" version="1">
          <linux:evr datatype="evr_string" operation="less than">{bversion}</linux:evr>
        </linux:dpkginfo_state>""".format(**mapping)

        return state

    def create_usn_variable(self, id_base, binaries_list):
        values = ""
        for binarie in binaries_list:
            values += \
            """<value>{}</value>
            """.format(binarie)

        mapping = {
            'id': id_base,
            'ns': self.ns,
            'values': values.strip()
        }

        constant_variable = \
        """
        <constant_variable id="{ns}:var:{id}" version="1" datatype="string" comment="?">
            {values}
        </constant_variable>""".format(**mapping)

        return constant_variable

    def load_current_oval(self, release, oval_path):
        pass

    def get_cve_info_from_file(self, cve):
        # We need to try in active and retired
        # since a USN is not guarantee the CVE
        # will be moved to retired.
        # FIXME: BUG: Some how CVE-2017-0605 appears but is not in any
        # place. So, skip it, since it's a ghost
        cve_active_file_path = os.path.join('./active', cve)
        cve_retired_file_path = os.path.join('./retired', cve)

        if os.path.exists(cve_active_file_path):
            cve_file_path = cve_active_file_path
        elif os.path.exists(cve_retired_file_path):
            cve_file_path = cve_retired_file_path
        else:
            return None

        with open(cve_file_path, 'r') as cve_file:
            cve_file_content = cve_file.read()
            priority = re.findall('Priority: (negligible|low|medium|high|critical)',
                                  cve_file_content)[0]
            cvss = re.findall('nvd: .+', cve_file_content)
            cvss = cvss[0].split(': ')[1] if cvss else None
            public_date = re.findall("PublicDate: .+", cve_file_content)
            public_date = public_date[0].split(': ')[1]

        cvss_values = cvss_score(cvss) if cvss else (None, None)

        cve_year = cve.split("-")[1]
        cve_info = {
                'Candidate': cve,
                'PublicDate': public_date,
                'Priority': priority,
                'CVSS': cvss,
                'CVSS_SEVERITY_LEVEL': cvss_values[0],
                'CVSS_SCORE': cvss_values[1],
                'CVE_URL': self.cve_base_url.format(cve_year, cve),
                'MITRE_URL': self.mitre_base_url.format(cve)
                }

        return cve_info

    # FIXME: BUG: USN adds lp urls to 'cves': field, we need to filter it
    # and handle it separated till USN data be fixed
    def filter_cves(self, cves):
        _cves = cves[:]
        urls = []
        for cve in cves:
            # Takes urls from the list
            is_url = re.match('(www|http:|https:)+[^\s]+[\w]', cve)

            if is_url:
                urls.append(cve)
                _cves.remove(cve)

        return (urls, _cves)

    def format_cves_info(self, cves):
        urls, cves = self.filter_cves(cves)
        cves_info = []
        for cve in cves:
            res = self.get_cve_info_from_file(cve)
            if res:
                cves_info.append(res)

        return urls, cves_info

    def get_version_from_binaries(self, usn_allbinaries):
        # We just need one, since all binaries has the same version
        version = usn_allbinaries[list(usn_allbinaries.keys())[0]]['version']
        return version

    def get_all_binaries_object(self, usn_object):
        usn_release = usn_object['releases'][self.release_codename]

        if 'allbinaries' in usn_release.keys():
            usn_allbinaries = usn_release['allbinaries']
        else:
            usn_allbinaries = usn_release['binaries']

        return usn_allbinaries

    def generate_usn_oval(self, usn_object, usn_number):
        if self.release_codename not in usn_object['releases'].keys():
            return

        usn_release = usn_object['releases'][self.release_codename]
        id_base = int(re.sub('[^0-9]','', usn_number)) * 1000000


        if 'allbinaries' in usn_release.keys():
            usn_allbinaries = usn_release['allbinaries']
        else:
            usn_allbinaries = usn_release['binaries']

        binarie_version = self.get_version_from_binaries(usn_allbinaries)

        self.oval_structure['definition'].write(self.create_usn_definition(usn_object, usn_number, id_base))
        self.oval_structure['test'].write(self.create_usn_test(id_base))
        self.oval_structure['object'].write(self.create_usn_object(id_base))
        self.oval_structure['state'].write(self.create_usn_state(binarie_version, id_base))
        self.oval_structure['variable'].write(self.create_usn_variable(id_base, usn_allbinaries))

    def write(self):
        for key in self.oval_structure:
            self.oval_structure[key].close()
            self.oval_structure[key] = open(self.oval_structure[key].name, 'rt')

        tmp = os.path.join(self.tmpdir, self.output_filepath)
        with open(tmp, 'wt') as f:
            # add header
            oval_timestamp = datetime.datetime.utcnow().strftime(
                '%Y-%m-%dT%H:%M:%S')
            copyright_year = datetime.datetime.utcnow().year
            f.write("""<oval_definitions
    xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5"
    xmlns:ind="http://oval.mitre.org/XMLSchema/oval-definitions-5#independent"
    xmlns:oval="http://oval.mitre.org/XMLSchema/oval-common-5"
    xmlns:unix="http://oval.mitre.org/XMLSchema/oval-definitions-5#unix"
    xmlns:linux="http://oval.mitre.org/XMLSchema/oval-definitions-5#linux"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://oval.mitre.org/XMLSchema/oval-common-5 oval-common-schema.xsd   http://oval.mitre.org/XMLSchema/oval-definitions-5 oval-definitions-schema.xsd   http://oval.mitre.org/XMLSchema/oval-definitions-5#independent independent-definitions-schema.xsd   http://oval.mitre.org/XMLSchema/oval-definitions-5#unix unix-definitions-schema.xsd   http://oval.mitre.org/XMLSchema/oval-definitions-5#macos linux-definitions-schema.xsd">

    <generator>
        <oval:product_name>Canonical USN OVAL Generator</oval:product_name>
        <oval:product_version>{0}</oval:product_version>
        <oval:schema_version>{1}</oval:schema_version>
        <oval:timestamp>{2}</oval:timestamp>
        <terms_of_use>Copyright (C) {3} Canonical LTD. All rights reserved. This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 3 of the License. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License version 3 for more details. You should have received a copy of the GNU General Public License version 3 along with this program.  If not, see http://www.gnu.org/licenses/.</terms_of_use>
    </generator>\n""".format(self.generator_version, self.oval_schema_version, oval_timestamp, copyright_year))

            # add queued file content
            for element in self.supported_oval_elements:
                if element in self.oval_structure:
                    f.write("\n    <{0}s>\n".format(element))
                    f.write(self.oval_structure[element].read().rstrip())
                    f.write("\n    </{0}s>".format(element))

            # add footer
            f.write("\n</oval_definitions>")

        # close and delete queue files
        for key in self.oval_structure:
            self.oval_structure[key].close()
            os.remove(self.oval_structure[key].name)

        # close self.output_filepath and move into place
        f.close()
        shutil.move(tmp, os.path.join(self.output_dir, self.output_filepath))
