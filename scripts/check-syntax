#!/usr/bin/env python3

# Author: Kees Cook <kees@ubuntu.com>
# Author: Jamie Strandboge <jamie@ubuntu.com>
# Author: Marc Deslauriers <marc.deslauriers@canonical.com>
# Copyright (C) 2005-2020 Canonical Ltd.
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 2 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.

# Set CVE_ALLOW_NEWER_PKGS=1 to skip new package checks
from __future__ import print_function

import glob
import optparse
import os
import pprint
import re
import sys
import subprocess
import signal

import cve_lib
import kernel_lib
import usn_lib

import source_map

source = source_map.load()
dev_proposed = source_map.load(pockets=["-proposed"], releases=[cve_lib.devel_release])

# add to this list when adding tracking for kernels that have not been
# published to updates/security yet. Once published, can be removed
# (script should warn about that). If a kernel is published in one
# release, but not yet in another release, add the unpublished release
# after a '/' e.g. 'linux-aws/trusty'
unpublished_kernels = []


def CVEs_from_CNA():
    """Returns a set of CVEs assigned from the README in the embargoed cna
    directory, using a space and text after CVE-NNNN-NNNN as indicator of
    which CVEs have been assigned."""
    lines = []
    try:
        # Assumes embargoed symlink/ exists in parent directory and points to ../embargoed/cves/
        f = open(
            os.path.dirname(os.path.dirname(os.path.realpath(__file__)))
            + "/embargoed/../cna/README"
        )
        lines = f.readlines()
        f.close()
    except IOError as e:
        print("Ignoring CNA sanity checks: %s\n" % e, file=sys.stderr)
        return {}

    # Assumes any text after CVE-NNNN-NNNN means "assigned"
    # Note the space is important, used for split(" ") later
    assigned_cves = re.compile(r"^CVE-\d\d\d\d-\d{4,7} .+")

    def find_assigned_cves(line):
        if "REJECTED" in line:
            return None
        if "IGNORED" in line:
            return None
        return assigned_cves.match(line)

    return {line.split(" ")[0] for line in filter(find_assigned_cves, lines)}


def ever_existed(pkg):
    for rel in cve_lib.all_releases:
        if rel in cve_lib.eol_releases:
            continue
        if rel in source and pkg in source[rel]:
            return True
    return False


def is_active(cve):
    return os.path.exists(os.path.join(cve_lib.active_dir, cve))


def is_embargoed(cve):
    return os.path.exists(os.path.join(cve_lib.embargoed_dir, cve))


def is_retired(cve):
    return os.path.exists(os.path.join(cve_lib.retired_dir, cve))


def is_unpublished_kernel(kernel, release=None, debug=False):
    for u in unpublished_kernels:
        unpub = u.split("/")
        if debug and kernel.startswith("linux-aws"):
            print("Checking %s/%s against %s" % (kernel, release, unpub))
        if unpub[0] == kernel and (
            len(unpub) == 1 or (len(unpub) == 2 and unpub[1] == release)
        ):
            return True
    return False


def subprocess_setup():
    # Python installs a SIGPIPE handler by default. This is usually not what
    # non-Python subprocesses expect.
    signal.signal(signal.SIGPIPE, signal.SIG_DFL)


def cmd(
    command,
    input=None,
    stderr=subprocess.STDOUT,
    stdout=subprocess.PIPE,
    stdin=None,
    timeout=None,
):
    """Try to execute given command (array) and return its stdout, or return
    a textual error if it failed."""

    try:
        sp = subprocess.Popen(
            command,
            stdin=stdin,
            stdout=stdout,
            stderr=stderr,
            close_fds=True,
            preexec_fn=subprocess_setup,
            universal_newlines=True,
        )
    except OSError as e:
        return [127, str(e)]

    out, outerr = sp.communicate(input)
    # Handle redirection of stdout
    if out is None:
        out = ""
    # Handle redirection of stderr
    if outerr is None:
        outerr = ""
    return [sp.returncode, outerr]


def get_bzr_filelist():
    rc, report = cmd(["bzr", "stat", "-S"])

    file_list = []
    for line in report.splitlines():
        if len(line.split()) == 2:
            if line.split()[0] != "D":
                file_list.append(line.split()[1])

    return file_list


def get_git_filelist():
    rc, report = cmd(["git", "diff", "--name-only", "--diff-filter=AM", "HEAD"])

    return report.splitlines()


def cve_lib_consistency_checks():
    # add additional consistency check calls here, if need be
    kernel_lib.meta_kernels.consistency_check()


parser = optparse.OptionParser()
parser.add_option(
    "-v",
    "--verbose",
    help="Enable verbose reporting",
    action="store_true",
    default=False,
)
parser.add_option(
    "-d", "--debug", help="Enable debug reporting", action="store_true", default=False
)
parser.add_option(
    "-u", "--usn-db", dest="usndb", help="Enable USN database on DB", metavar="DB"
)
parser.add_option(
    "-n",
    "--newer",
    help="Allow versions newer than what is in the archive",
    action="store_true",
    default=False,
)
parser.add_option(
    "-s",
    "--strict",
    help="Be extra strict in syntax",
    action="store_true",
    default=False,
)
parser.add_option(
    "-f", "--filelist", help="Use a list of files to work on", metavar="FILE"
)
parser.add_option(
    "-m",
    "--modified",
    help="Only check modified files",
    action="store_true",
    default=False,
)
parser.add_option(
    "--subproject",
    help="Check subproject's CVE files. Comma-separated projects",
    action="append",
    default=[],
)
# parser.add_option("-c", "--cna", help="Ensure every CVE assigned by Canonical's CNA has an entry", action='store_true')
(opt, args) = parser.parse_args()

if opt.debug:
    pp = pprint.PrettyPrinter(indent=4)

all_okay = True
cves_updated = False
warned_kernels = []
esm_warned = False

supported_releases = []
for rel in cve_lib.all_releases:
    if rel not in cve_lib.eol_releases + [cve_lib.devel_release]:
        supported_releases.append(rel)
supported_releases.append("devel")

cve_lib_consistency_checks()

cves = dict()
if opt.usndb:
    usn_db = usn_lib.load_database(opt.usndb)
    reverted = usn_lib.get_reverted()

    # create a dictionary of key=CVE value=USNs
    for usn in usn_db:
        if "cves" not in usn_db[usn]:
            continue
        for cve in usn_db[usn]["cves"]:
            if not cve.startswith("CVE-"):
                continue
            if usn in reverted and cve in reverted[usn]:
                continue
            if cve not in cves:
                cves[cve] = []
                cves[cve].append(usn)
            else:
                cves[cve].append(usn)

check_dirs = [cve_lib.active_dir, cve_lib.retired_dir, cve_lib.ignored_dir]
if os.path.islink(cve_lib.embargoed_dir):
    check_dirs.append(cve_lib.embargoed_dir)
if opt.subproject:
    source.update(source_map.load(subprojects=opt.subproject))
    for sb in opt.subproject:
        check_dirs.append(cve_lib.subprojects_dir + "/" + sb)

if opt.debug:
    pp.pprint("check_dirs %s" % check_dirs)

all_files = True
if len(args) == 0:
    if opt.filelist:
        if opt.debug:
            pp.pprint("Using filelist %s" % opt.filelist)

        all_files = False
        with open(opt.filelist) as fh:
            for line in fh:
                for dir in check_dirs:
                    if line.startswith("%s/CVE-" % dir) or line.startswith("%s/00boilerplate" % dir):
                        args += [line.rstrip()]
    elif opt.modified:
        if opt.debug:
            pp.pprint("Checking modified files only")

        all_files = False

        if os.path.exists(".git"):
            file_list = get_git_filelist()
        else:
            file_list = get_bzr_filelist()

        for filename in file_list:
            filename = os.path.join(os.getcwd(), filename)
            for dir in check_dirs:
                if filename.startswith("%s/CVE-" % dir):
                    args += [filename]
    else:
        for dir in check_dirs:
            for cve in sorted(glob.glob("%s/CVE-*" % dir)):
                args += [cve]
else:
    all_files = False

if opt.debug:
    pp.pprint("args %s" % args)

ignored = cve_lib.parse_CVEs_from_uri("%s/not-for-us.txt" % cve_lib.ignored_dir)

if opt.debug:
    pp.pprint("ignored %s" % ignored)

cna_cves_set = CVEs_from_CNA()
# Just run this if we're not specifying specific CVEs
if len(cna_cves_set) > 0 and all_files:
    cve_name_re = re.compile(r"(CVE-\d\d\d\d-\d{4,7})")

    def filter_cves(fname):
        return re.search(cve_name_re, fname)

    def find_cves(fname):
        m = re.search(cve_name_re, fname)
        if m:
            return m.group(1)
        else:
            print("unmatched %s\n" % fname, file=sys.stderr)

    ignored_set = set(ignored)
    args_set = {find_cves(name) for name in filter(filter_cves, args)}

    if opt.debug:
        pp.pprint("cna_cves_set: %s\n" % cna_cves_set)
        pp.pprint("ignored_set: %s\n" % ignored_set)
        pp.pprint("args: %s" % args)
        pp.pprint("filtered_args: %s" % filter(filter_cves, args))
        pp.pprint("args_set: %s\n" % args_set)

    # if we ever assign a CVE then ignore it (vbulletin comes to mind...)
    # we can use the "IGNORED" tag to skip these checks
    martians = cna_cves_set & ignored_set
    if len(martians) > 0:
        print(
            "%d ignored CVEs that we assigned: %s\n" % (len(martians), martians),
            file=sys.stderr,
        )

    too_private = cna_cves_set - args_set
    if len(too_private) == 1:
        print(
            "%d CVE that we assigned needs an UCT entry: %s\n"
            % (len(too_private), too_private),
            file=sys.stderr,
        )
    elif len(too_private) > 1:
        print(
            "%d CVEs that we assigned need UCT entries: %s\n"
            % (len(too_private), too_private),
            file=sys.stderr,
        )


# Date patterns for formatted as YYYY-MM-DD HH:MM:SS
date_only_pat = re.compile(r"^20[0-9][0-9]-[01][0-9]-[0-3][0-9]$")
date_time_pat = re.compile(
    r"^20[0-9][0-9]-[01][0-9]-[0-3][0-9] [0-2][0-9]:[0-5][0-9]:[0-5][0-9](| [A-Z]+| [+-][01][0-9]+)$"
)
for cve in args:
    if re.match(r"EMB-", cve):
        cvepath = os.path.join(cve_lib.embargoed_dir, cve)
    elif re.match(r"CVE-", cve):
        cvepath = os.path.join(cve_lib.active_dir, cve)
    else:
        cvepath = cve
    cve = os.path.basename(cvepath)

    cve_okay = True
    srcmap = dict()
    try:
        if opt.subproject:
            data = cve_lib.load_cve(cve_lib.find_cve(cve), opt.strict, srcmap=srcmap, subprojects=opt.subproject)
        else:
            data = cve_lib.load_cve(cvepath, opt.strict, srcmap=srcmap)
    except ValueError as e:
        print(e, file=sys.stderr)
        all_okay = False
        continue

    if cve in ignored:
        print(
            "%s: %d: duplicate CVE found in not-for-us.txt" % (cvepath, 1),
            file=sys.stderr,
        )
        all_okay = False
    matches = set()
    for dir in [
        cve_lib.active_dir,
        cve_lib.retired_dir,
        cve_lib.ignored_dir,
        cve_lib.embargoed_dir,
    ]:
        if os.path.exists(os.path.join(dir, cve)):
            matches.add(dir)
    if len(matches) > 1:
        print(
            "%s: %d: found in multiple classes: %s"
            % (cvepath, 1, ", ".join(sorted(matches))),
            file=sys.stderr,
        )
        all_okay = False

    # verify candidate field matches the CVE file name
    if "stdin" not in cve and "boilerplate" not in cve and not data["Candidate"] == cve:
        print(
            "%s: %d: Candidate field '%s' mismatch with cve pathname '%s'"
            % (cvepath, srcmap["Candidate"], data["Candidate"], cve),
            file=sys.stderr,
        )
        cve_okay = False

    supported = []
    for pkg in sorted(data["pkgs"].keys()):
        # Verify have supported release for each package
        if is_active(cve):
            if (
                "product" not in data["pkgs"][pkg].keys()
                and "snap" not in data["pkgs"][pkg].keys()
            ):
                for rel in supported_releases:
                    if rel not in sorted(data["pkgs"][pkg].keys()):
                        print(
                            "%s: %d: %s missing supported release '%s'"
                            % (cvepath, 1, pkg, rel),
                            file=sys.stderr,
                        )
                        cve_okay = False

        # Verify packages exist for releases
        for release in sorted(data["pkgs"][pkg].keys()):
            rel = release

            # Handle just after release, but before devel has opened
            if rel == "devel" and cve_lib.devel_release == "":
                continue

            # Adjust devel release name
            if rel == "devel":
                rel = cve_lib.devel_release
            # Don't syntax check upstream
            if rel == "upstream":
                continue
            # ensure is a valid product or snap
            if rel == "product":
                if pkg not in cve_lib.supported_products:
                    print(
                        "%s: %d: unknown product '%s'"
                        % (cvepath, srcmap["pkgs"][pkg][rel], pkg),
                        file=sys.stderr,
                    )
                    cve_okay = False
                continue
            if rel == "snap":
                if pkg not in cve_lib.supported_snaps:
                    print(
                        "%s: %d: unknown snap '%s'"
                        % (cvepath, srcmap["pkgs"][pkg][rel], pkg),
                        file=sys.stderr,
                    )
                    cve_okay = False
                continue
            # Don't syntax check end-of-lifed releases
            if rel in cve_lib.eol_releases:
                continue

            state = data["pkgs"][pkg][release][0]

            # Skip devel checks on retired CVEs
            if release == "devel":
                if "retired/" in cvepath:
                    # but first check to ensure that state is not open
                    if state in ["needed", "needs-triage", "pending"]:
                        print(
                            "%s: %d: retired but %s is listed as unfixed (%s) for '%s'"
                            % (cvepath, srcmap["pkgs"][pkg][release], pkg, state, rel),
                            file=sys.stderr,
                        )
                        cve_okay = False
                    continue

            # Skip DNE's
            if state == "DNE":
                if pkg in source[rel]:
                    # TODO: remove this when partner archive is back in sync
                    # sigh, partner archive mirrors are out of date since removing sun-java6
                    if pkg == "sun-java6" and source[rel][pkg]["section"] == "partner":
                        continue
                    print(
                        "%s: %d: package '%s' DOES exist in '%s'!"
                        % (cvepath, srcmap["pkgs"][pkg][release], pkg, rel),
                        file=sys.stderr,
                    )
                    cve_okay = False
                continue

            # Check for released-esm as it is not a valid state on UCT
#            if state == "released-esm":
#                print(
#                    "%s: %d: %s_%s has invalid state: '%s'"
#                    % (cvepath, srcmap["pkgs"][pkg][release], release, pkg, state)
#                )
#                cve_okay = False

            # check any notes have balanced parentheses
            if len(data["pkgs"][pkg][release]) > 1:
                note = data["pkgs"][pkg][release][1]
                if note.count("(") != note.count(")"):
                    print(
                        "%s: %d: %s_%s has unbalanced parentheses in state annotation: '%s %s'"
                        % (cvepath, srcmap["pkgs"][pkg][release], release, pkg, state, note)
                    )
                    cve_okay = False

            # Check that package exists in a given release
            if not ever_existed(pkg):
                if is_active(cve):
                    # forcibly skip linux-lts-backport packages and #
                    # other derived kernels since want to track them
                    # before they end up fully in the archive;
                    # additional kernels can be added to
                    # unpublished_kernels as needed
                    if pkg.startswith("linux-lts-") or is_unpublished_kernel(pkg, rel):
                        if opt.debug:
                            print(
                                "%s: %d: skipping unpublished kernel '%s'"
                                % (cvepath, srcmap["pkgs"][pkg][release], pkg),
                                file=sys.stderr,
                            )
                        continue
                    print(
                        "%s: %d: unknown package '%s'"
                        % (cvepath, srcmap["pkgs"][pkg][release], pkg),
                        file=sys.stderr,
                    )
                    cve_okay = False
            else:
                if rel in source:
                    if pkg not in source[rel]:
                        if is_active(cve):
                            if is_unpublished_kernel(pkg, rel):
                                if opt.debug:
                                    print(
                                        "%s: %d: skipping unpublished kernel '%s'"
                                        % (cvepath, srcmap["pkgs"][pkg][release], pkg),
                                        file=sys.stderr,
                                    )
                                continue
                            # is this package released for ESM, even though is not in
                            # supported list? ignore it
                            if "esm" in rel and cve_lib.is_active_esm_release(rel.split("/esm")[0]):
                                    if state == "released" and not cve_lib.is_supported(
                                        source, pkg, rel, data
                                    ):
                                        continue
                            # Just a warning if this is the devel release, package may be
                            # in -proposed.
                            # TODO: actually check -proposed.
                            if release == "devel" and pkg in dev_proposed[rel]:
                                if opt.debug:
                                    print(
                                        "%s: %d: WARNING: package '%s' not in '%s' (found in -proposed)"
                                        % (cvepath, srcmap["pkgs"][pkg][release], pkg, rel),
                                        file=sys.stderr,
                                    )
                            else:
                                print(
                                    "%s: %d: package '%s' not in '%s'"
                                    % (cvepath, srcmap["pkgs"][pkg][release], pkg, rel),
                                    file=sys.stderr,
                                )
                                cve_okay = False
                elif opt.strict and not opt.newer:
                    # Validate the version is <= version in release
                    # Unfortuanely, had to move this to --strict, as
                    # some older nvidia updates trigger this check.
                    if state == "released":
                        released = data["pkgs"][pkg][release][1]
                        # XXX 'version' existence check should not be needed
                        if "version" not in source[rel][pkg]:
                            if not esm_warned:
                                print(
                                    "%s: %d: unable to lookup source version for %s in %s"
                                    % (cvepath, srcmap["pkgs"][pkg][release], pkg, rel),
                                    file=sys.stderr,
                                )
                                print(
                                    "-- This is likely due to missing version info in source_map.py for the ESM release",
                                    file=sys.stderr,
                                )
                                esm_warned = True
                        elif (
                            source_map.version_compare(
                                released, source[rel][pkg]["version"]
                            )
                            > 0
                        ):
                            print(
                                "%s: %d: %s has %s > %s (in %s)"
                                % (
                                    cvepath,
                                    srcmap["pkgs"][pkg][release],
                                    pkg,
                                    released,
                                    source[rel][pkg]["version"],
                                    rel,
                                ),
                                file=sys.stderr,
                            )
                            cve_okay = False
                # this is a check-syntax self-sanity check; we're
                # looking for kernels that were in the
                # unpublished_kernels list that have subsequently been
                # published and should be checked for existence.
                if is_active(cve) and is_unpublished_kernel(pkg, rel):
                    # we'll only issue a warning the first time we come
                    # across a kernel that's been published
                    if pkg not in warned_kernels:
                        print(
                            "kernel '%s/%s' is now published; please remove from unpublished_kernels list in check-syntax. (%s)"
                            % (pkg, rel, cve),
                            file=sys.stderr,
                        )
                        warned_kernels.append(pkg)

            # Is this package unfixed and considered supported?
            if state not in ["released-esm", "released", "not-affected"] and cve_lib.is_supported(
                source, pkg, rel, data
            ):
                supported.append("%s/%s" % (pkg, rel))

            if (
                len(data["pkgs"][pkg][release]) > 1
                and state != "deferred"
                and "deferred" in data["pkgs"][pkg][release][1]
            ):
                print(
                    "%s: %d: %s uses 'deferred' with '%s'. Use: 'deferred [(YYYY-MM-DD)]'"
                    % (cvepath, srcmap["pkgs"][pkg][release], pkg, state),
                    file=sys.stderr,
                )
                cve_okay = False

    # Verify priority for any CVE with a supported package and when this is
    # not boilerplate
    if (
        "boilerplate" not in cve and
        len(supported)
        and (is_active(cve) or is_embargoed(cve))
        and ("Priority" not in data or data["Priority"] not in cve_lib.priorities)
    ):
        print(
            "%s: %d: Priority missing with supported packages (%s)"
            % (
                cvepath,
                srcmap["Priority"] if "Priority" in srcmap else 1,
                ", ".join(supported),
            ),
            file=sys.stderr,
        )
        cve_okay = False

    # Verify per-package and per-package-release priorities
    for pkg_priority in [x for x in data if "Priority_" in x]:
        fields = pkg_priority.split("_", 2)
        if len(fields) == 2:
            pkg = fields[1]
            if pkg not in data["pkgs"]:
                print(
                    "%s: %d: per package priority (%s) does not match any package in cve"
                    % (cvepath, srcmap[pkg_priority], pkg),
                    file=sys.stderr,
                )
                cve_okay = False
        elif len(fields) == 3:
            pkg, release = fields[1:3]
            if pkg not in data["pkgs"]:
                print(
                    "%s: %d: per package/release priority (%s/%s) does not match a package/release pair in cve"
                    % (cvepath, srcmap[pkg_priority], pkg, release),
                    file=sys.stderr,
                )
                cve_okay = False
            elif (
                release not in cve_lib.all_releases and not release == "devel"
            ) or release not in data["pkgs"][pkg]:
                print(
                    "%s: %d: invalid release in per package/release priority pair (%s/%s)"
                    % (cvepath, srcmap[pkg_priority], pkg, release),
                    file=sys.stderr,
                )
                cve_okay = False

        # print(pkg_priority, file=sys.stderr)

    # check to see if the description has been changed to rejected by
    # MITRE, we should move CVE to ignored state.
    if (
        is_active(cve)
        and "Description" in data
        and data["Description"].lstrip().startswith("** REJECT **")
    ):
        print(
            "%s: %d: Rejected by MITRE (possibly a duplicate of another CVE?)"
            % (cvepath, srcmap["Description"]),
            file=sys.stderr,
        )
        cve_okay = False

    # check for CVE reference
    if re.match(r"^CVE-\d+-\d+$", cve):
        found = False
        mitre_ref = "https://cve.mitre.org/cgi-bin/cvename.cgi?name=" + cve
        if "References" in data:
            if mitre_ref in data["References"]:
                found = True
        if not found:
            print(
                "WARNING: %s: %d: does not contain reference to %s"
                % (
                    cvepath,
                    srcmap["References"] if "References" in srcmap else 1,
                    mitre_ref,
                ),
                file=sys.stderr,
            )
            cve_okay = False

    # check for URLs if using the USN database
    if opt.usndb and "ignored/" not in cvepath and cve in cves and len(cves[cve]) > 0:
        if "References" in data:
            for usn in cves[cve]:
                found = False
                usn_ref = "http://www.ubuntu.com/usn/usn-" + usn
                text = data["References"].strip()
                if len(text) != 0:
                    for line in text.split("\n"):
                        if line == usn_ref:
                            found = True
                if not found:
                    print(
                        "%s: %d: does not contain reference to %s"
                        % (
                            cvepath,
                            srcmap["References"] if "References" in srcmap else 1,
                            usn_ref,
                        ),
                        file=sys.stderr,
                    )
                    cve_okay = False

    # Either PublicDate or CRD must be set to something
    if ("boilerplate" not in cve and
        ("PublicDate" not in data or data["PublicDate"] == "") and (
        "CRD" not in data or data["CRD"] == ""
    )):
        print(
            "%s: %d: must specify at least one of PublicDate or CRD as a valid date or unknown"
            % (
                cvepath,
                srcmap["PublicDate"]
                if "PublicDate" in srcmap
                else srcmap["CRD"]
                if "CRD" in srcmap
                else 1,
            ),
            file=sys.stderr,
        )

    for d in ["PublicDate", "PublicDateAtUSN", "CRD"]:
        if d in data and data[d] not in ["", "unknown"]:
            if (
                date_only_pat.search(data[d]) is None
                and date_time_pat.search(data[d]) is None
            ):
                print(
                    "%s: %d: does not contain a valid %s '%s' (need YYYY-MM-DD HH:MM:SS [TIMEZONE], an empty string, or 'unknown')"
                    % (cvepath, srcmap[d] if d in srcmap else 1, d, data[d]),
                    file=sys.stderr,
                )
                cve_okay = False

    # Check to make sure all patch references match the type:reference
    # pattern
    for key in data.keys():
        if "Patches_" in key and len(data[key]) > 0:
            for line in re.split("\n", data[key]):
                patch_type = re.split(":", line)[0]
                if re.search("http", patch_type):
                    print(
                        "%s: %d: patch reference %s doesn't contain a type modifier (e.g. upstream:)"
                        % (cvepath, srcmap[key] if key in srcmap else 1, key),
                        file=sys.stderr,
                    )
                    cve_okay = False
                if re.search("patch", patch_type):
                    print(
                        "%s: %d: invalid type modifier in %s, please use upstream:, vendor:, debdiff:, other:, etc."
                        % (cvepath, srcmap[key] if key in srcmap else 1, key),
                        file=sys.stderr,
                    )
                    cve_okay = False

    # check for cvss entries with unknown origin
    for (origin, cvss) in data["CVSS"]:
        if origin == 'unknown':
            print("%s: %d: CVSS with unknown origin" % (cvepath, srcmap["CVSS"][source]), file=sys.stderr)
            cve_okay = False

    # Report on failures
    if not cve_okay:
        all_okay = False
    elif opt.debug:
        pp.pprint(data)

    # update eol status
    for pkg in sorted(data["pkgs"].keys()):
        if cve_lib.lts_unsupported(source, cvepath, pkg) != "":
            cves_updated = True

if cves_updated:
    print("CVEs updated. Please run again.", file=sys.stderr)
    all_okay = False

if all_okay and opt.verbose:
    print("OK: %d CVEs" % (len(args)))
# Invert boolean for unix exit code
sys.exit(not all_okay)
